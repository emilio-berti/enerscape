---
title: "enerscape"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{enerscape}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---
  
```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 6,
  fig.height = 6
)
```
  
```{r download data}
# library(raster)
# library(enerscape)
# 
# # download and load the digital elevation model for Stromboli island 
# tmp <- tempfile()
# download.file("http://tinitaly.pi.ingv.it/data/w43010_s10/w43010_s10.zip",
# tmp)
# 
# unzip(tmp, exdir = tempdir())
# d <- unzip(tmp, list = TRUE)
# dem <- raster(file.path(tempdir(), d$Name))
# dem <- aggregate(dem, 10)
# dem <- trim(crop(dem, extent(1037488, 1042488, 4309837, 4314455)))
# # remove sea-level locations
# dem[dem == 0] <- NA
# plot(dem)
```
  
```{r energy landscape}
# # get energy landscape for a 10 kg terrestrial animal
# en <- enerscape(dem, 10, units = "kcal")
# # plot_enerscape(en, n_contour = 5)
# plot(en$work, col = topo.colors(100))
```

# Least cost paths

There are two ways to get the least cost paths. In the first, we specify origin and destination points, whereas in the second we specify the number of random points to evaluate. Both ways are implemented in the *en_shortest_path()* function. *en_shortest_path()* has always two mandatory input, *dem* (a digital elevation model raster layer) and *m* (the body mass of the animal).

## Specifying two points

If we specify two points, we just pass them to *en_shortest_path()* as *or* (origin) and *dest* (destination) arguments.

```{r en_shortest_path example}
# p <- data.frame(x = c(1038500, 1041000),
#                 y = c(4312000, 4312000))
# A <- p[1, ]
# B <- p[2, ]
# short <- en_shortest_path(dem, 1, or = A, dest = B)
```

The object returned by *en_shortest_path()* is a list with elements:

   1. *$rasters* - four raster layers showing: 
      * DEM = digital elevation model
      * Slope = slope
      * Work = energy cost of locomotion
      * Conductance = conductance, i.e. 1 / Work
   2. *$`shortest path`* - the shortest path:
      * Cost = energetic costs (in kcal)
      * Path = path as SpatialLines

```{r short plot}
# plot(short$rasters$Conductance)
# lines(short$`shortest path`$Path, lw = 2, lt = 2)
```

Notably, the direction of the movement is important, and it is wise to expect the least cost path between two points to change when the direction is reversed. Moreover, energy costs of animal of different body mass vary, also affecting least cost paths. In the example below, least cost paths between two points *A* and *B* for two animals of 1 kg and 50 kg are computed and shown.

```{r least cost paths}
# # 1 kg animal
# short_1kg_AB <- en_shortest_path(dem, 1, or = A, dest = B)
# short_1kg_BA <- en_shortest_path(dem, 1, or = B, dest = A)
# # 50 kg animal
# short_50kg_AB <- en_shortest_path(dem, 50, or = A, dest = B)
# short_50kg_BA <- en_shortest_path(dem, 50, or = B, dest = A)
# 
# results <- list(short_1kg_AB, short_50kg_AB, short_1kg_BA, short_50kg_BA)
# 
# results <- data.frame(
#   Origin = rep(c("A", "B"), each = 2),
#   Destination = rep(c("B", "A"), each = 2),
#   Mass = rep(c("1kg", "50kg"), 2),
#   Distance = sapply(results, function(x) {
#     SpatialLinesLengths(x[["shortest path"]][["Path"]])
#   }),lines(short$`shortest path`$Path, lw = 2, lt = 2)
# 
#   Cost_kcal = sapply(results, function(x) {
#     x[["shortest path"]][["Cost"]]
#   })
# )
# results
```

## Specifying the number of random points

If we want to generate the least cost path between *n* number of random points, we need to specify *simulate_random_points = TRUE* in *en_shortest_path()*. The optional argument *rep* (default = 10) specify the number of pairs to generate.

```{r least cost path random points}
# short <- en_shortest_path(dem, 
#                              50, 
#                              simulate_random_points = TRUE,
#                              rep = 20)
```

In this case, the object returned by *en_shortest_path()* is a list with elements:

   1. *$rasters* - four raster layers showing: 
      * DEM = digital elevation model
      * Slope = slope
      * Work = energy cost of locomotion
      * Conductance = conductance, i.e. 1 / Work
   2. *$sims* - the shortest path:
      * Costs = energetic costs (in kcal)
      * Origins = random origin points
      * Destinations = random destination points
      * Paths = paths as SpatialLines
      
# Circuitscape

Circuitscape is 

Download for different platforms can be found at: https://circuitscape.org/downloads. 

# Circuitscape with Julia

https://github.com/Circuitscape/Circuitscape.jl

```{r, eval=FALSE}
[Circuitscape Mode]
data_type = raster
scenario = pairwise

[Version]
version = 5.0.0

[Habitat raster or graph]
habitat_file = /home/eb97ziwi/Proj/enerscape-paper/data/orso-work.tif
habitat_map_is_resistances = true

[Connection Scheme for raster habitat data]
connect_four_neighbors_only = false
connect_using_avg_resistances = false

[Short circuit regions (aka polygons)]
use_polygons = true
polygon_file = /home/eb97ziwi/Proj/enerscape-paper/data/orso-loc.tif

[Options for advanced mode]
ground_file_is_resistances = true
source_file = (Browse for a current source file)
remove_src_or_gnd = keepall
ground_file = (Browse for a ground point file)
use_unit_currents = false
use_direct_grounds = false

[Mask file]
use_mask = false
mask_file = None

[Options for one-to-all and all-to-one modes]
use_variable_source_strengths = false
variable_source_file = None

[Options for pairwise and one-to-all and all-to-one modes]
included_pairs_file = (Browse for a file with pairs to include or exclude)
use_included_pairs = false
point_file = /home/eb97ziwi/Proj/enerscape-paper/data/orso-loc.tif

[Calculation options]
solver = cg+amg

[Output options]
write_cum_cur_map_only = false
log_transform_maps = false
output_file = /home/eb97ziwi/Proj/enerscape-paper/circuitscape/cs
write_max_cur_maps = false
write_volt_maps = true
set_null_currents_to_nodata = false
set_null_voltages_to_nodata = false
compress_grids = false
write_cur_maps = true
```

Save this file as the simple text file */home/eb97ziwi/Proj/enerscape-paper/orso-circuitscape* and then open a julia terminal and type:

```{r, eval=FALSE}
using Circuitscape
compute("/home/eb97ziwi/Proj/enerscape-paper/orso-circuitscape")
```

```{r, eval=FALSE}
[ Info: 2020-11-27 09:15:34 : Precision used: Double
[ Info: 2020-11-27 09:15:38 : Reading maps
[ Info: 2020-11-27 09:15:39 : Resistance/Conductance map has 575361 nodes
[ Info: 2020-11-27 09:15:46 : Solver used: AMG accelerated by CG
[ Info: 2020-11-27 09:15:46 : Graph has 575361 nodes, 2 focal points and 1 connected components
[ Info: 2020-11-27 09:15:46 : Total number of pair solves = 1
[ Info: 2020-11-27 09:15:49 : Time taken to construct preconditioner = 2.293156562 seconds
[ Info: 2020-11-27 09:15:49 : Time taken to construct local nodemap = 0.070405472 seconds
[ Info: 2020-11-27 09:15:49 : Solving pair 1 of 1
[ Info: 2020-11-27 09:15:50 : Time taken to solve linear system = 1.282343393 seconds
[ Info: 2020-11-27 09:15:51 : Time taken to write voltage maps = 0.504518614 seconds
[ Info: 2020-11-27 09:15:51 : Time taken to write current maps = 0.716189859 seconds
[ Info: 2020-11-27 09:15:52 : Time taken to complete job = 17.743505455
3Ã—3 Array{Float64,2}:
 0.0   1.0      2.0
 1.0   0.0     15.5381
 2.0  15.5381   0.0
```
